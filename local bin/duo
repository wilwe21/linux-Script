#!/usr/bin/env python3
# profiles, lvls, more lessons, more challenge, challenges, and more
import yaml, argparse, random, wonderwords, datetime, string
from dateutil.relativedelta import relativedelta
from pathlib import Path
def translate(word, side = "lern") -> str:
    if side == "lern":
        return ''.join(lern.get(ch,ch) for ch in word)
    if side == "normal":
        for key, value in normdub.items():
            word = word.replace(key, value)
        return ''.join(normsing.get(ch,ch) for ch in word)
def qchoice() -> None:
    wor = w.word()
    print(f"{translate(wor)} means")
    wors = w.random_words(4, word_min_length=len(wor), word_max_length=len(wor))
    wors[random.randint(0,3)] = wor
    wo = [f"{wors.index(wo)+1} {wo}" for wo in wors] 
    print('\n'.join(wo))
    try:
        ans = input("Which one: ")
    except KeyboardInterrupt:
        exit()
    anin = True
    try:
        ans = int(ans)
    except:
        anin = False
    if ans == wor:
        print("Great")
    elif anin and wor == wors[ans-1]:
        print("Great")
    else:
        print(f"Correct answer is {wor}")
        raise ValueError("Braille or you'll stay blank")
def qchar() -> None:
    le = random.choice(string.ascii_lowercase)
    print(f"{translate(le)} is")
    les = [random.choice(string.ascii_lowercase) for i in range(4)]
    les[random.randint(0,3)] = le
    woles = [f"{les.index(lo)+1} {lo}" for lo in les]
    print('\n'.join(woles))
    try:
        ans = input("Which one: ").lower()
    except KeyboardInterrupt:
        exit()
    anin = True
    try:
        ans = int(ans)
    except:
        anin = False
    if ans == le:
        print("Great")
    elif anin and le == les[ans-1]:
        print("Great")
    else:
        print(f"Correct asnwer is {le}")
        raise ValueError("Braille or you'll stay blank")
def menu() -> None:
    print("\033cWelcome to duolingo for blind")
    if not first:
        streakf(check = True)
    livs()
    print(f"Your current streak: {streak}")
    print(f"Lives: {lives}")
    options = ["Play", "Options", "Exit"]
    opts = [f"{options.index(op)+1} {op}" for op in options]
    print("\n".join(opts))
    try:
        opt = input("Which to play: ").lower()
    except KeyboardInterrupt:
        exit()
    if opt in ["play", "p", "1"]:
        play()
    if opt in ["options", "o", "2"]:
        option()
    if opt in ["exit", "e", ":q", "3"]:
        exit()
def option() -> None:
    print("\033cOptions")
    options = ["reset strek","check lives","Show alphabet"]
    opts = [f"{options.index(i)+1} {i}" for i in options]
    print('\n'.join(opts))
    try:
        ans = input("Which one: ").lower()
    except KeyboardInterrupt:
        exit()
    if ans in ["reset streak", "1"]:
        streakf(True)
    if ans in ["check lives", "2"]:
        livs(ver=True)
    if ans in ["show alpthabet", "3"]:
        alpha()
def play() -> None:
    global lives, ldat
    playmodes = ["char", "choice"]
    if lives == 0:
        print("You don't have lives")
    else:
        for i in range(lessonLength):
            if lives > 0:
                livs()
                try:
                    play = random.choice(playmodes)
                    if play == "char":
                        qchar()
                    elif play == "choice":
                        qchoice()
                except ValueError:
                    lives -= 1
                    if lives != maxlive:
                        ldat = ftime + datetime.timedelta(minutes=30) 
                        conf.update({"lives": lives, "ldat": ldat})
                    else:
                        conf.update({"lives": lives})
                    with open(f"{Path.home()}/.config/duo.yaml", "r+") as f:
                        yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
            else:
                print("Your lives are gone")
                break
        if lives > 0:
            print("Congrats you compleat a lesson")
            lvlup()
            streakf()
def streakf(rest: bool = False, check: bool = False) -> None:
    global streak
    up = False
    if check:
        ness = datetime.datetime.strptime((sdata + relativedelta(days=1)).strftime("%Y.%m.%d"), "%Y.%m.%d")
        if ness < time:
            print("Your streak gone")
            print("I'm at your door now")
            conf.update({"streak": {"count": 0}})
            streak = 0
            up = True 
    else:
        if rest:
            conf.update({"streak": {"count": 0, "data": (time - relativedelta(days=1)).strftime("%Y.%m.%d")}})
            streak = 0
            up = True
        else:
            nex = sdata + relativedelta(days=1)
            if sdata < time:
                conf.update({"streak": {"count": streak+1, "data": (time + relativedelta(days=1)).strftime("%Y.%m.%d") }})
                streak += 1
                up = True
                print(f"Your streak raise: {streak}")
    if up:
        with open(f"{Path.home()}/.config/duo.yaml", "r+") as f:
            yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
def livs(ver: bool = False) -> None:
    global lives, ldat
    if lives != maxlive and ftime > ldat:
        lives += 1
        ldat = ldat + datetime.timedelta(minutes=30)
        if lives == maxlive:
            conf.update({"lives": lives, "ldat": None})
        else:
            conf.update({"lives": lives, "ldat": ldat})
            livs()
        with open(f"{Path.home()}/.config/duo.yaml", "r+") as f:
            yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
    elif lives != maxlive and ver:
        print("No time for new lives")
        print(f"Next lives come {ldat.strftime('%Y.%m.%d %H:%m:%S')}")
        print(f"You have {lives} lives")
    elif lives == maxlive and ver:
        print("You have maximum amount of lives")
        print(f"You have {lives} lives")
def lvlup(count: int = 1) -> None:
    global lvl
    lvl += count
def alpha() -> None:
    end = ""
    for key, value in lern.items():
        end = end + f"{key}:{value} "
    print(end)
def main() -> None:
    global time, ftime, w, streak, sdata, lives, lvl, ldat, maxlive, lessonLength, conf, first, lern, normsing, normdub
    time = datetime.datetime.strptime(datetime.datetime.now().strftime("%Y.%m.%d"), "%Y.%m.%d")
    ftime = datetime.datetime.now()
    first = False
    try:
        with open(f"{Path.home()}/.config/duo.yaml", "r+") as f:
            conf = yaml.load(f, Loader=yaml.FullLoader)
    except:
        first = True
        dat = time - relativedelta(days=1)
        with open(f"{Path.home()}/.config/duo.yaml", "w+") as f:
            conf = {"streak": {"count": 0, "data": dat.strftime("%Y.%m.%d")}, "lvl": 0, "lives": 5, "maxlives": 5, "ldat": ftime, "length": 5, "lern": {"a": "⠁","b": "⠃","c": "⠉","d": "⠙","e": "⠑","f": "⠋","g": "⠛","h": "⠓","i": "⠊","j": "⠚","k": "⠅","l": "⠇","m": "⠍","n": "⠝","o": "⠕","p": "⠏","q": "⠟","r": "⠗","s": "⠎","t": "⠞","u": "⠥","v": "⠧","w": "⠺","x": "⠭","y": "⠽","z": "⠵","ą":"⠡","ć":"⠩","ę":"⠱","ł":"⠣","ń":"⠹","ó":"⠬","ś":"⠪","ż":"⠯","ź":"⠮","0":"⠼⠚","1":"⠼⠁","2":"⠼⠃","3":"⠼⠉","4":"⠼⠙","5":"⠼⠑","6":"⠼⠋","7":"⠼⠛","8":"⠼⠓","9":"⠼⠊","-": "⠒",".": "⠲","'": "⡀",",": "⠂"},"normal": { "single": {"⠁":"a","⠃":"b","⠉":"c","⠙":"d","⠑":"e","⠋":"f","⠛":"g","⠓":"h","⠊":"i","⠚":"j","⠅":"k","⠇":"l","⠍":"m","⠝":"n","⠕":"o","⠏":"p","⠟":"q","⠗":"r","⠎":"s","⠞":"t","⠥":"u","⠧":"v","⠺":"w","⠭":"x","⠽":"y","⠵":"z","⠡":"ą","⠩":"ć","⠱":"ę","⠣":"ł","⠹":"ń","⠬":"ó","⠪":"ś","⠯":"ż","⠮":"ź","-": "⠒",".":"⠲","'": "⡀",",":"⠂"}, "doubles": {"⠼⠚": "0","⠼⠁": "1", "⠼⠃": "2","⠼⠉": "3","⠼⠙": "4","⠼⠑": "5","⠼⠋": "6","⠼⠛": "7","⠼⠓": "8","⠼⠊": "9"}}}
            yaml.dump(conf, f, allow_unicode=True, sort_keys=False)
    streak = conf["streak"]["count"]
    sdata = datetime.datetime.strptime(conf["streak"]["data"], "%Y.%m.%d")
    lvl = conf["lvl"]
    lives = conf["lives"]
    ldat = conf["ldat"]
    maxlive = conf["maxlives"]
    lessonLength = conf["length"]
    try:
        lern = conf["lern"]
    except:
        raise ValueError("Lern characters cant be empty")
    try:
        normsing = conf["normal"]["single"]
    except:
        normsing = None
    try:
        normdub = conf["normal"]["dubles"]
    except:
        normdub = None
    w = wonderwords.RandomWord()
    menu()

if __name__ == "__main__":
    main()
